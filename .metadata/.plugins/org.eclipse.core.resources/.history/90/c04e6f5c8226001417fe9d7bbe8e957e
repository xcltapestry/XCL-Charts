/**
 * Copyright 2014  XCL-Charts
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 	
 * @Project XCL-Charts 
 * @Description Android图表基类库
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 * @license http://www.apache.org/licenses/  Apache v2 License
 * @version 1.0
 */
package org.xclcharts.common;

import java.math.BigDecimal;

import android.graphics.PointF;


/**
 * @ClassName MathHelper
 * @Description  集中了 图形相关的一些用于计算的小函数
 * @author XiongChuanLiang<br/>(xcl_168@aliyun.com)
 *  
 */

public class MathHelper {

	private static MathHelper instance = null;
	
	//Position位置
	private float mPosX = 0.0f;
	private float mPosY = 0.0f;
	private PointF mPointF = new PointF();
	
	//除法运算精度
	private static final int DEFAULT_DIV_SCALE = 10;	
	private BigDecimal mBgNum1 ;
	private BigDecimal mBgNum2 ;
		
	public MathHelper()
	{	
	}
	
	public static synchronized MathHelper getInstance()
	{
		 if(instance == null)
		 {
			 instance = new MathHelper();
		 }
		 return instance;
	}
	
	public float getPosX() {
		return mPosX;
	}
		
	public float getPosY() {
		return mPosY;
	}	
	
	private void resetEndPointXY()
	{
		mPosX = mPosY = 0.0f;
		mPointF.x = mPosX;
		mPointF.y = mPosY;
	}
	
	
	//依圆心坐标，半径，扇形角度，计算出扇形终射线与圆弧交叉点的xy坐标	
	public PointF calcArcEndPointXY(float cirX, 
									float cirY, 
									float radius, 
									float cirAngle)
	{	
		resetEndPointXY();		
		/*
		if( (Float.compare(cirAngle, 0.0f) == -1 || Float.compare(cirAngle, 0.0f) == 0 ) || 
			(Float.compare(radius, 0.0f) == 0 || Float.compare(radius, 0.0f) == -1  ) )
		{
			 return mPointF;		
		}
		*/
			
		//将角度转换为弧度		
	    float arcAngle = (float) (Math.PI *  div(cirAngle , 180.0f));
	    if( Float.compare(arcAngle,0.0f) == -1)mPosX = mPosY = 0.0f;	
	    
	    if (Float.compare(cirAngle , 90.0f) == -1)
	    {	    		    
	    	mPosX = add(cirX , (float)Math.cos(arcAngle) * radius);
	        mPosY = add(cirY , (float)Math.sin(arcAngle) * radius) ;
	    }
	    else if (Float.compare(cirAngle,00.0f) == 0)
	    {
	        mPosX = cirX;
	        mPosY = add(cirY , radius);
	    }
	    else if (Float.compare(cirAngle,90.0f) == 1 &&
	    		 Float.compare(cirAngle,180.0f) == -1)
	    {
	    	arcAngle = (float) (Math.PI * (sub(180f , cirAngle)) / 180.0f);	 	    		    		    		    
	        mPosX = sub(cirX , (float) (Math.cos(arcAngle) * radius));
	        mPosY = add(cirY , (float) (Math.sin(arcAngle) * radius));
	    }
	    else if (Float.compare(cirAngle,180.0f) == 0)
	    {
	        mPosX = (float) (cirX - radius);
	        mPosY = cirY;
	    }
	    else if (Float.compare(cirAngle,180.0f) == 1 &&
	    		 Float.compare(cirAngle,270.0f) == -1) 
	    {
	    	arcAngle = (float) (Math.PI * ( sub(cirAngle , 180.0f)) / 180.0f);
	        mPosX = sub(cirX , (float) (Math.cos(arcAngle) * radius));
	        mPosY = sub(cirY , (float) (Math.sin(arcAngle) * radius));
	    }
	    else if (Float.compare(cirAngle,270.0f) == 0)
	    {
	        mPosX = cirX;
	        mPosY = sub (cirY , radius);
	    }
	    else
	    {
	    	arcAngle = (float) (Math.PI * ( sub(360.0f , cirAngle )) / 180.0f);
	        mPosX = add(cirX , (float) (Math.cos(arcAngle) * radius)) ;
	        mPosY = sub(cirY , (float) (Math.sin(arcAngle) * radius));
	    }
	    	    
	    mPointF.x = mPosX;
	    mPointF.y = mPosY;	    
	    return mPointF;				
	}
	
	public PointF getArcEndPointF()
	{		
		return mPointF;
	}
	
	
	//两点间的角度
	public double getDegree(float sx, float sy, float tx, float ty) 
    {
        float nX = tx - sx;
        float nY = ty - sy;
        double angrad = 0d,angel = 0d,tpi = 0d;
        float tan = 0.0f;
        
        if (Float.compare(nX ,0.0f) != 0) {
            tan = Math.abs(nY / nX);
            angel  = Math.atan(tan);
            
            if ( Float.compare(nX,0.0f) == 1 )
            {
            	if( Float.compare(nY,0.0f) == 1 || Float.compare(nY,0.0f) ==  0)
            	{
            		 angrad = angel;
            	}else{
            		 angrad = 2 * Math.PI - angel;
            	}
            }else{
            	if( Float.compare(nY,0.0f) == 1 || Float.compare(nY,0.0f) ==  0)
            	{
            		angrad = Math.PI - angel;
            	}else{
            		angrad = Math.PI + angel;
            	}
            }                      

        } else {
        	tpi  = Math.PI / 2;        	
        	if( Float.compare(nY,0.0f) == 1)
        	{
        		angrad = tpi;
        	}else{
        		angrad = -1 * tpi;
        	}
        }        
        return  Math.toDegrees(angrad);
    }
		
    //两点间的距离
    public double getDistance(float sx,float sy,float tx,float ty)
    {	 
    	float nx =  Math.abs(tx - sx);
        float ny =  Math.abs(ty - sy);	         
        return Math.sqrt(Math.hypot(nx, ny));      
    }	
    
    private void restBigDecimal()
    {
    	if(null != mBgNum1)mBgNum1 = BigDecimal.ZERO;
    	if(null != mBgNum2)mBgNum2 = BigDecimal.ZERO;
    }
	 
	/**
	 * 加法运算
	 * @param v1
	 * @param v2
	 * @return
	 */
	 public float add(float v1, float v2) 
	 {
		 
		 // BigDecimal mBgNum1 = new BigDecimal(Float.toString(v1));		
		  mBgNum1 = new BigDecimal(Float.toString(v1));
		  
		  BigDecimal mBgNum2 = new BigDecimal(Float.toString(v2));
		  return mBgNum1.add(mBgNum2).floatValue();
	 }
		 
	 /**
	  * 减法运算
	  * @param v1
	  * @param v2
	  * @return 运算结果
	  */
	 public float sub(float v1, float v2) 
	 {
		 restBigDecimal();
		 mBgNum1 = new BigDecimal(Float.toString(v1));		 		 
		 mBgNum2 = new BigDecimal(Float.toString(v2));
		 return mBgNum1.subtract(mBgNum2).floatValue();
	 }
		 
	 /**
	  * 乘法运算
	  * @param v1
	  * @param v2
	  * @return 运算结果
	  */
	 public float mul(float v1, float v2) 
	 {
		  restBigDecimal();
		  mBgNum1 = new BigDecimal(Float.toString(v1));
		  mBgNum2 = new BigDecimal(Float.toString(v2));
		  return mBgNum1.multiply(mBgNum2).floatValue();
	 }
		 
	 /**
	  * 除法运算,当除不尽时，精确到小数点后10位
	  * @param v1
	  * @param v2
	  * @return 运算结果
	  */
	 public float div(float v1, float v2)
	 {
		  return div(v1, v2, DEFAULT_DIV_SCALE);
	 }
		 
	 /**
	  * 除法运算,当除不尽时，精确到小数点后scale位
	  * @param v1
	  * @param v2
	  * @param scale
	  * @return 运算结果
	  */
	 public float div(float v1, float v2, int scale) 
	 {
		  if (scale < 0) 
		   throw new IllegalArgumentException("The scale must be a positive integer or zero");
		
		  restBigDecimal();
		  mBgNum1 = new BigDecimal(Float.toString(v1));
		  mBgNum2 = new BigDecimal(Float.toString(v2));
		  return mBgNum1.divide(mBgNum2, scale, BigDecimal.ROUND_HALF_UP).floatValue();
	 }
		 
	 /**
	  * 四舍五入到小数点后scale位
	  * @param v
	  * @param scale
	  * @return 
	  */
	 public float round(float v, int scale) 
	 {
		  if (scale < 0) 
			  throw new IllegalArgumentException("The scale must be a positive integer or zero");
		
		  restBigDecimal();
		  mBgNum1 = new BigDecimal(Float.toString(v));
		  mBgNum2 = new BigDecimal("1");
		  return mBgNum1.divide(mBgNum2, scale, BigDecimal.ROUND_HALF_UP).floatValue();		  
		 // return b.setScale(scale, BigDecimal.ROUND_HALF_UP).floatValue();
	 }
	
	 /**
	  * float(4字节)转double(8字节),防止 补位误差.
	  * @param f
	  * @return
	  */
	public double ftod(float f)
	{
		return(new Float(f).doubleValue());
	}
	
	/**
	 * double转float
	 * @param d
	 * @return
	 */
	public float dtof(double d)
	{
		return (new Double(d).floatValue());
	}
	
	 public double add(double v1, double v2) 
	 {
		  restBigDecimal();
		  mBgNum1 = new BigDecimal(Double.toString(v1));
		  mBgNum2 = new BigDecimal(Double.toString(v2));
		  return mBgNum1.add(mBgNum2).doubleValue();
	 }
	 
	 public double sub(double v1, double v2) 
	 {
		 restBigDecimal();
		 mBgNum1 = new BigDecimal(Double.toString(v1));
		 mBgNum2 = new BigDecimal(Double.toString(v2));
		 return mBgNum1.subtract(mBgNum2).doubleValue();
	 }
	 
	 public double div(double v1, double v2) 
	 {
		 return div(v1,v2,DEFAULT_DIV_SCALE);
	 }
	 
	 public double div(double v1, double v2, int scale) 
	 {
		  if (scale < 0) 
		   throw new IllegalArgumentException("The scale must be a positive integer or zero");
		
		  restBigDecimal();
		  mBgNum1 = new BigDecimal(Double.toString(v1));
		  mBgNum2 = new BigDecimal(Double.toString(v2));
		  return mBgNum1.divide(mBgNum2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();
	 }	 	 	
}
